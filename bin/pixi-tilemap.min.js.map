{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/CanvasTileRenderer.js","pixi-tilemap.min.js","src/CompositeRectTileLayer.js","src/GraphicsLayer.js","src/RectTileLayer.js","src/RectTileShader.js","src/SquareTileShader.js","src/TileRenderer.js","src/ZLayer.js","src/index","src/shaderGenerator.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","CanvasTileRenderer","renderer","this","tileAnim","PIXI","CanvasRenderer","registerPlugin","2","CompositeRectTileLayer","Container","apply","arguments","initialize","RectTileLayer","prototype","Object","create","constructor","updateTransform","displayObjectUpdateTransform","zIndex","bitmaps","useSquare","texPerChild","z","shadowColor","Float32Array","setBitmaps","len1","children","len2","Math","ceil","textures","slice","addChild","clear","modificationMarker","addRect","num","v","x","y","tileWidth","tileHeight","addFrame","texture","Texture","fromImage","layer","ind","tex","j","baseTexture","child","push","frame","width","height","renderCanvas","dontUseTransform","wt","worldTransform","context","setTransform","b","c","d","tx","resolution","ty","layers","renderWebGL","shader","gl","plugins","tile","getShader","setObjectRenderer","bindShader","_globalMat","Matrix","_activeRenderTarget","projectionMatrix","copy","append","uniforms","toArray","tempScale","_tempScale","pointScale","projectionScale","abs","animationFrame","isModified","anim","pointsBuf","hasAnim","clearModify","./RectTileLayer","3","GraphicsLayer","Graphics","transform","IDENTITY","graphics","render","globalAlpha","_webGL","id","dirty","4","DisplayObject","Array","visible","_tempSize","_tempTexSize","points","fillStyle","x1","y1","x2","y2","w","h","textureId","drawImage","source","fillRect","animX","animY","pb","rectsCount","checkIndexBuffer","len","maxTextures","valid","bindTextures","vb","getVb","vbId","createVb","vbBuffer","vao","bind","vertices","vertPerQuad","vs","stride","byteLength","bk","ArrayBuffer","vbArray","vbInts","Uint32Array","upload","shiftU","shiftV","arr","sz","eps","drawArrays","POINTS","drawElements","TRIANGLES","UNSIGNED_SHORT","5","RectTileShader","Shader","shaderGenerator","generateFragmentSrc","vertSize","fillSamplers","createVao","addIndex","indexBuffer","addAttribute","attributes","aVertexPosition","FLOAT","aTextureCoord","aFrame","aAnim","aTextureId","./shaderGenerator","6","SquareTileShader","aSize","7","TileRenderer","ObjectRenderer","vbs","lastTimeCheck","indices","glCore","vbAutoincrement","SCALE_MODE","SCALE_MODES","DEFAULT","onContextChange","rectShader","squareShader","glTextures","boundSprites","initBounds","tempCanvas","document","createElement","glt","GLTexture","premultiplyAlpha","enableWrapClamp","LINEAR","enableLinearScaling","enableNearestScaling","bs","spr","Sprite","position","_hackSubImage","sprite","baseTex","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","texSubImage2D","TEXTURE_2D","format","type","bounds","glts","bindTexture","_activeTextureLocation","checkLeaks","now","Date","old","key","lastTimeAccess","removeVb","start","state","setBlendMode","BLEND_MODES","NORMAL","lastAccessTime","GLBuffer","createVertexBuffer","STREAM_DRAW","stuff","destroy","size","totalIndices","Uint16Array","createIndexBuffer","STATIC_DRAW","WebGLRenderer","./RectTileShader","./SquareTileShader","8","ZLayer","tilemap","_previousLayers","cacheIfDirty","modified","buf","canvasBuffer","tempRender","_tempRender","view","rootContext","_layerWidth","_layerHeight","_lastAnimationFrame","_hackRenderer","clearRect","layerTransform","9","./CanvasTileRenderer","./CompositeRectTileLayer","./GraphicsLayer","./TileRenderer","./ZLayer","10","sampleValues","uSamplers","samplerSize","uSamplerSize","fragmentSrc","replace","generateSampleSrc","src"],"mappings":"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","file":"pixi-tilemap.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","function CanvasTileRenderer(renderer) {\r\n    this.renderer = renderer;\r\n    this.tileAnim = [0, 0];\r\n}\r\n\r\nPIXI.CanvasRenderer.registerPlugin('tile', CanvasTileRenderer);\r\n\r\nmodule.exports = CanvasTileRenderer;\r\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nfunction CanvasTileRenderer(renderer) {\r\n    this.renderer = renderer;\r\n    this.tileAnim = [0, 0];\r\n}\r\n\r\nPIXI.CanvasRenderer.registerPlugin('tile', CanvasTileRenderer);\r\n\r\nmodule.exports = CanvasTileRenderer;\r\n\n},{}],2:[function(require,module,exports){\nvar RectTileLayer = require('./RectTileLayer');\r\n\r\nfunction CompositeRectTileLayer() {\r\n    PIXI.Container.apply(this, arguments);\r\n    this.initialize.apply(this, arguments);\r\n}\r\n\r\nCompositeRectTileLayer.prototype = Object.create(PIXI.Container.prototype);\r\nCompositeRectTileLayer.prototype.constructor = RectTileLayer;\r\nCompositeRectTileLayer.prototype.updateTransform = CompositeRectTileLayer.prototype.displayObjectUpdateTransform;\r\n\r\n//can be initialized multiple times\r\nCompositeRectTileLayer.prototype.initialize = function (zIndex, bitmaps, useSquare, texPerChild) {\r\n    this.z = this.zIndex = zIndex;\r\n    this.useSquare = useSquare;\r\n    this.shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\r\n    this.texPerChild = texPerChild || 16;\r\n    if (bitmaps) {\r\n        this.setBitmaps(bitmaps);\r\n    }\r\n};\r\n\r\nCompositeRectTileLayer.prototype.setBitmaps = function (bitmaps) {\r\n    var texPerChild = this.texPerChild;\r\n    var len1 = this.children.length;\r\n    var len2 = Math.ceil(bitmaps.length / texPerChild);\r\n    var i;\r\n    for (i = 0; i < len1; i++) {\r\n        this.children[i].textures = bitmaps.slice(i * texPerChild, (i + 1) * texPerChild);\r\n    }\r\n    for (i = len1; i < len2; i++) {\r\n        this.addChild(new RectTileLayer(this.zIndex, bitmaps.slice(i * texPerChild, (i + 1) * texPerChild)));\r\n    }\r\n};\r\n\r\nCompositeRectTileLayer.prototype.clear = function () {\r\n    for (var i = 0; i < this.children.length; i++)\r\n        this.children[i].clear();\r\n    this.modificationMarker = 0;\r\n};\r\n\r\nCompositeRectTileLayer.prototype.addRect = function (num, u, v, x, y, tileWidth, tileHeight) {\r\n    if (this.children[num] && this.children[num].textures)\r\n        this.children[num].addRect(0, u, v, x, y, tileWidth, tileHeight);\r\n};\r\n\r\n/**\r\n * \"hello world!\" of pixi-tilemap library. Pass it texture and it will be added\r\n * @param texture\r\n * @param x\r\n * @param y\r\n * @returns {boolean}\r\n */\r\nCompositeRectTileLayer.prototype.addFrame = function (texture, x, y) {\r\n    if (typeof texture === \"string\") {\r\n        texture = PIXI.Texture.fromImage(texture);\r\n    }\r\n    var children = this.children;\r\n    var layer = null, ind = 0;\r\n    for (var i = 0; i < children.length; i++) {\r\n        var tex = children[i].textures;\r\n        for (var j = 0; j < tex.length; j++) {\r\n            if (tex[j].baseTexture == texture.baseTexture) {\r\n                layer = children[i];\r\n                ind = j;\r\n                break;\r\n            }\r\n        }\r\n        if (layer) {\r\n            break;\r\n        }\r\n    }\r\n    if (!layer) {\r\n        for (i = 0; i < children.length; i++) {\r\n            var child = children[i];\r\n            if (child.textures.length < 16) {\r\n                layer = child;\r\n                ind = child.textures.length;\r\n                child.textures.push(texture);\r\n            }\r\n        }\r\n        if (!layer) {\r\n            children.push(layer = new RectTileLayer(this.zIndex, texture));\r\n            ind = 0;\r\n        }\r\n    }\r\n    layer.addRect(ind, texture.frame.x, texture.frame.y, x, y, texture.frame.width, texture.frame.height);\r\n    return true;\r\n};\r\n\r\nCompositeRectTileLayer.prototype.renderCanvas = function (renderer) {\r\n    if (!renderer.dontUseTransform) {\r\n        var wt = this.worldTransform;\r\n        renderer.context.setTransform(\r\n            wt.a,\r\n            wt.b,\r\n            wt.c,\r\n            wt.d,\r\n            wt.tx * renderer.resolution,\r\n            wt.ty * renderer.resolution\r\n        );\r\n    }\r\n    var layers = this.children;\r\n    for (var i = 0; i < layers.length; i++)\r\n        layers[i].renderCanvas(renderer);\r\n};\r\n\r\n\r\nCompositeRectTileLayer.prototype.renderWebGL = function (renderer) {\r\n    var gl = renderer.gl;\r\n    var shader = renderer.plugins.tile.getShader(this.useSquare);\r\n    renderer.setObjectRenderer(renderer.plugins.tile);\r\n    renderer.bindShader(shader);\r\n    //TODO: dont create new array, please\r\n    this._globalMat = this._globalMat || new PIXI.Matrix();\r\n    renderer._activeRenderTarget.projectionMatrix.copy(this._globalMat).append(this.worldTransform);\r\n    shader.uniforms.projectionMatrix = this._globalMat.toArray(true);\r\n    shader.uniforms.shadowColor = this.shadowColor;\r\n    if (this.useSquare) {\r\n        var tempScale = this._tempScale = (this._tempScale || [0, 0]);\r\n        tempScale[0] = this._globalMat.a >= 0 ? 1 : -1;\r\n        tempScale[1] = this._globalMat.d < 0 ? 1 : -1;\r\n        var ps = shader.uniforms.pointScale = tempScale;\r\n        shader.uniforms.projectionScale = Math.abs(this.worldTransform.a) * renderer.resolution;\r\n    }\r\n    var af = shader.uniforms.animationFrame = renderer.plugins.tile.tileAnim;\r\n    //shader.syncUniform(shader.uniforms.animationFrame);\r\n    var layers = this.children;\r\n    for (var i = 0; i < layers.length; i++)\r\n        layers[i].renderWebGL(renderer, this.useSquare);\r\n};\r\n\r\n\r\nCompositeRectTileLayer.prototype.isModified = function (anim) {\r\n    var layers = this.children;\r\n    if (this.modificationMarker != layers.length) {\r\n        return true;\r\n    }\r\n    for (var i = 0; i < layers.length; i++) {\r\n        if (layers[i].modificationMarker != layers[i].pointsBuf.length ||\r\n            anim && layers[i].hasAnim) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nCompositeRectTileLayer.prototype.clearModify = function () {\r\n    var layers = this.children;\r\n    this.modificationMarker = layers.length;\r\n    for (var i = 0; i < layers.length; i++) {\r\n        layers[i].modificationMarker = layers[i].pointsBuf.length;\r\n    }\r\n};\r\n\r\nmodule.exports = CompositeRectTileLayer;\r\n\n},{\"./RectTileLayer\":4}],3:[function(require,module,exports){\nfunction GraphicsLayer(zIndex) {\r\n    PIXI.Graphics.apply(this, arguments);\r\n    this.z = this.zIndex = zIndex;\r\n}\r\n\r\nGraphicsLayer.prototype = Object.create(PIXI.Graphics.prototype);\r\nGraphicsLayer.prototype.constructor = GraphicsLayer;\r\nGraphicsLayer.prototype.renderCanvas = function (renderer) {\r\n    var wt = null;\r\n    if (renderer.dontUseTransform) {\r\n        wt = this.transform.worldTransform;\r\n        this.transform.worldTransform = PIXI.Matrix.IDENTITY;\r\n    }\r\n    renderer.plugins.graphics.render(this);\r\n    if (renderer.dontUseTransform) {\r\n        this.transform.worldTransform = wt;\r\n    }\r\n    renderer.context.globalAlpha = 1.0;\r\n};\r\nGraphicsLayer.prototype.renderWebGL = function(renderer) {\r\n    if (!this._webGL[renderer.gl.id])\r\n        this.dirty = true;\r\n    PIXI.Graphics.prototype.renderWebGL.call(this, renderer);\r\n};\r\n\r\nGraphicsLayer.prototype.isModified = function(anim) {\r\n    return false;\r\n};\r\n\r\nGraphicsLayer.prototype.clearModify = function() {\r\n};\r\n\r\nmodule.exports = GraphicsLayer;\r\n\n},{}],4:[function(require,module,exports){\nfunction RectTileLayer(zIndex, texture) {\r\n    PIXI.DisplayObject.apply(this, arguments);\r\n    this.initialize.apply(this, arguments);\r\n}\r\n\r\nRectTileLayer.prototype = Object.create(PIXI.DisplayObject.prototype);\r\nRectTileLayer.prototype.constructor = RectTileLayer;\r\n\r\nRectTileLayer.prototype.initialize = function(zIndex, textures) {\r\n    if (!textures) {\r\n        textures = [];\r\n    } else if (!(textures instanceof Array) && textures.baseTexture) {\r\n        textures = [textures];\r\n    }\r\n    this.textures = textures;\r\n    this.z = this.zIndex = zIndex;\r\n    this.pointsBuf = [];\r\n    this.visible = false;\r\n    this._tempSize = new Float32Array([0, 0]);\r\n    this._tempTexSize = 1;\r\n};\r\n\r\nRectTileLayer.prototype.clear = function () {\r\n    this.pointsBuf.length = 0;\r\n    this.modificationMarker = 0;\r\n    this.hasAnim = false;\r\n};\r\n\r\nRectTileLayer.prototype.renderCanvas = function (renderer) {\r\n    if (this.textures.length === 0) return;\r\n    var points = this.pointsBuf;\r\n    renderer.context.fillStyle = '#000000';\r\n    for (var i = 0, n = points.length; i < n; i += 9) {\r\n        var x1 = points[i], y1 = points[i+1];\r\n        var x2 = points[i+2], y2 = points[i+3];\r\n        var w = points[i+4];\r\n        var h = points[i+5];\r\n        x1 += points[i+6] * renderer.plugins.tile.tileAnim[0];\r\n        y1 += points[i+7] * renderer.plugins.tile.tileAnim[1];\r\n        var textureId = points[i+8];\r\n        if (textureId >= 0) {\r\n            renderer.context.drawImage(this.textures[textureId].baseTexture.source, x1, y1, w, h, x2, y2, w, h);\r\n        } else {\r\n            renderer.context.globalAlpha = 0.5;\r\n            renderer.context.fillRect(x2, y2, w, h);\r\n            renderer.context.globalAlpha = 1;\r\n        }\r\n    }\r\n};\r\n\r\nRectTileLayer.prototype.addRect = function (textureId, u, v, x, y, tileWidth, tileHeight, animX, animY) {\r\n    var pb = this.pointsBuf;\r\n    this.hasAnim = this.hasAnim || animX > 0 || animY > 0;\r\n    if (tileWidth == tileHeight) {\r\n        pb.push(u);\r\n        pb.push(v);\r\n        pb.push(x);\r\n        pb.push(y);\r\n        pb.push(tileWidth);\r\n        pb.push(tileHeight);\r\n        pb.push(animX | 0);\r\n        pb.push(animY | 0);\r\n        pb.push(textureId);\r\n    } else {\r\n        var i;\r\n        if (tileWidth % tileHeight === 0) {\r\n            //horizontal line on squares\r\n            for (i=0;i<tileWidth/tileHeight;i++) {\r\n                pb.push(u + i * tileHeight);\r\n                pb.push(v);\r\n                pb.push(x + i * tileHeight);\r\n                pb.push(y);\r\n                pb.push(tileHeight);\r\n                pb.push(tileHeight);\r\n                pb.push(animX | 0);\r\n                pb.push(animY | 0);\r\n                pb.push(textureId);\r\n            }\r\n        } else if (tileHeight % tileWidth === 0) {\r\n            //vertical line on squares\r\n            for (i=0;i<tileHeight/tileWidth;i++) {\r\n                pb.push(u);\r\n                pb.push(v + i * tileWidth);\r\n                pb.push(x);\r\n                pb.push(y + i * tileWidth);\r\n                pb.push(tileWidth);\r\n                pb.push(tileWidth);\r\n                pb.push(animX | 0);\r\n                pb.push(animY | 0);\r\n                pb.push(textureId);\r\n            }\r\n        } else {\r\n            //ok, ok, lets use rectangle. but its not working with square shader yet\r\n            pb.push(u);\r\n            pb.push(v);\r\n            pb.push(x);\r\n            pb.push(y);\r\n            pb.push(tileWidth);\r\n            pb.push(tileHeight);\r\n            pb.push(animX | 0);\r\n            pb.push(animY | 0);\r\n            pb.push(textureId);\r\n        }\r\n    }\r\n};\r\n\r\nRectTileLayer.prototype.renderWebGL = function(renderer, useSquare) {\r\n    var points = this.pointsBuf;\r\n    if (points.length === 0) return;\r\n    var rectsCount = points.length / 9;\r\n    var tile = renderer.plugins.tile;\r\n    var gl = renderer.gl;\r\n    if (!useSquare) {\r\n        tile.checkIndexBuffer(rectsCount);\r\n    }\r\n\r\n    var shader = tile.getShader(useSquare);\r\n    var textures = this.textures;\r\n    if (textures.length === 0) return;\r\n    var len = textures.length;\r\n    if (this._tempTexSize < shader.maxTextures) {\r\n        this._tempTexSize = shader.maxTextures;\r\n        this._tempSize = new Float32Array(2*shader.maxTextures);\r\n    }\r\n    // var samplerSize = this._tempSize;\r\n    for (var i=0;i<len;i++) {\r\n        if (!textures[i] || !textures[i].valid) return;\r\n        var texture = textures[i].baseTexture;\r\n        // samplerSize[i * 2] = 1.0 / texture.width;\r\n        // samplerSize[i * 2 + 1] = 1.0 / texture.height;\r\n    }\r\n    tile.bindTextures(renderer, textures);\r\n    // shader.uniforms.uSamplerSize = samplerSize;\r\n    //lost context! recover!\r\n    var vb = tile.getVb(this.vbId);\r\n    if (!vb) {\r\n        vb = tile.createVb(useSquare);\r\n        this.vbId = vb.id;\r\n        this.vbBuffer = null;\r\n        this.modificationMarker = 0;\r\n    }\r\n    var vao = vb.vao.bind();\r\n    vb = vb.vb;\r\n    //if layer was changed, re-upload vertices\r\n    vb.bind();\r\n    var vertices = rectsCount * shader.vertPerQuad;\r\n    if (vertices === 0) return;\r\n    if (this.modificationMarker != vertices) {\r\n        this.modificationMarker = vertices;\r\n        var vs = shader.stride * vertices;\r\n        if (!this.vbBuffer || this.vbBuffer.byteLength < vs) {\r\n            //!@#$ happens, need resize\r\n            var bk = shader.stride;\r\n            while (bk < vs) {\r\n                bk *= 2;\r\n            }\r\n            this.vbBuffer = new ArrayBuffer(bk);\r\n            this.vbArray = new Float32Array(this.vbBuffer);\r\n            this.vbInts = new Uint32Array(this.vbBuffer);\r\n            vb.upload(this.vbBuffer, 0, true);\r\n        }\r\n\r\n        var arr = this.vbArray, ints = this.vbInts;\r\n        //upload vertices!\r\n        var sz = 0;\r\n        //var tint = 0xffffffff;\r\n        var textureId, shiftU, shiftV;\r\n        if (useSquare) {\r\n            for (i = 0; i < points.length; i += 9) {\r\n                textureId = (points[i+8] >> 2);\r\n                shiftU = 1024 * (points[i+8] & 1);\r\n                shiftV = 1024 * ((points[i+8] >> 1) & 1);\r\n                arr[sz++] = points[i + 2];\r\n                arr[sz++] = points[i + 3];\r\n                arr[sz++] = points[i + 0] + shiftU;\r\n                arr[sz++] = points[i + 1] + shiftV;\r\n                arr[sz++] = points[i + 4];\r\n                arr[sz++] = points[i + 6];\r\n                arr[sz++] = points[i + 7];\r\n                arr[sz++] = textureId;\r\n            }\r\n        } else {\r\n            //var tint = 0xffffffff;\r\n            var tint = -1;\r\n            for (i = 0;i<points.length;i += 9) {\r\n                var eps = 0.5;\r\n                textureId = (points[i+8] >> 2);\r\n                shiftU = 1024 * (points[i+8] & 1);\r\n                shiftV = 1024 * ((points[i+8] >> 1) & 1);\r\n                var x = points[i+2], y = points[i+3];\r\n                var w = points[i+4], h = points[i+5];\r\n                var u = points[i] + shiftU, v = points[i+1] + shiftV;\r\n                var animX = points[i+6], animY = points[i+7];\r\n                arr[sz++] = x;\r\n                arr[sz++] = y;\r\n                arr[sz++] = u;\r\n                arr[sz++] = v;\r\n                arr[sz++] = u;\r\n                arr[sz++] = v ;\r\n                arr[sz++] = u + w - 2*eps;\r\n                arr[sz++] = v + h - 2*eps;\r\n                arr[sz++] = animX;\r\n                arr[sz++] = animY;\r\n                arr[sz++] = textureId;\r\n                arr[sz++] = x + w;\r\n                arr[sz++] = y;\r\n                arr[sz++] = u + w;\r\n                arr[sz++] = v;\r\n                arr[sz++] = u;\r\n                arr[sz++] = v;\r\n                arr[sz++] = u + w - 2*eps;\r\n                arr[sz++] = v + h - 2*eps;\r\n                arr[sz++] = animX;\r\n                arr[sz++] = animY;\r\n                arr[sz++] = textureId;\r\n                arr[sz++] = x + w;\r\n                arr[sz++] = y + h;\r\n                arr[sz++] = u + w;\r\n                arr[sz++] = v + h;\r\n                arr[sz++] = u;\r\n                arr[sz++] = v;\r\n                arr[sz++] = u + w - 2*eps;\r\n                arr[sz++] = v + h - 2*eps;\r\n                arr[sz++] = animX;\r\n                arr[sz++] = animY;\r\n                arr[sz++] = textureId;\r\n                arr[sz++] = x;\r\n                arr[sz++] = y + h;\r\n                arr[sz++] = u;\r\n                arr[sz++] = v + h;\r\n                arr[sz++] = u;\r\n                arr[sz++] = v;\r\n                arr[sz++] = u + w - 2*eps;\r\n                arr[sz++] = v + h - 2*eps;\r\n                arr[sz++] = animX;\r\n                arr[sz++] = animY;\r\n                arr[sz++] = textureId;\r\n            }\r\n        }\r\n        // if (vs > this.vbArray.length/2 ) {\r\n        vb.upload(arr, 0, true);\r\n        // } else {\r\n        //     var view = arr.subarray(0, vs);\r\n        //     vb.upload(view, 0);\r\n        // }\r\n    }\r\n    if (useSquare)\r\n        gl.drawArrays(gl.POINTS, 0, vertices);\r\n    else\r\n        gl.drawElements(gl.TRIANGLES, rectsCount * 6, gl.UNSIGNED_SHORT, 0);\r\n};\r\n\r\nmodule.exports = RectTileLayer;\r\n\n},{}],5:[function(require,module,exports){\nvar shaderGenerator = require('./shaderGenerator');\r\n\r\nfunction RectTileShader(gl, maxTextures)\r\n{\r\n    PIXI.Shader.call(this, gl,\r\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\n\\nattribute vec2 aTextureCoord;\\n\\nattribute vec4 aFrame;\\n\\nattribute vec2 aAnim;\\n\\nattribute float aTextureId;\\n\\nuniform mat3 projectionMatrix;\\n\\nuniform vec2 animationFrame;\\n\\nvarying vec2 vTextureCoord;\\n\\nvarying float vTextureId;\\n\\nvarying vec4 vFrame;\\n\\nvoid main(void){\\n\\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n   vec2 anim = aAnim * animationFrame;\\n\\n   vTextureCoord = aTextureCoord + anim;\\n\\n   vFrame = aFrame + vec4(anim, anim);\\n\\n   vTextureId = aTextureId;\\n\\n}\\n\\n\",\r\n        shaderGenerator.generateFragmentSrc(maxTextures, \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\n\\nvarying vec4 vFrame;\\n\\nvarying float vTextureId;\\n\\nuniform vec4 shadowColor;\\n\\nuniform sampler2D uSamplers[%count%];\\n\\nuniform vec2 uSamplerSize[%count%];\\n\\nvoid main(void){\\n\\n   vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\\n\\n   float textureId = floor(vTextureId + 0.5);\\n\\n   vec4 color;\\n\\n   %forloop%\\n\\n   gl_FragColor = color;\\n\\n}\\n\\n\")\r\n    );\r\n    this.maxTextures = maxTextures;\r\n    this.vertSize = 11;\r\n    this.vertPerQuad = 4;\r\n    this.stride = this.vertSize * 4;\r\n    shaderGenerator.fillSamplers(this, this.maxTextures);\r\n}\r\n\r\nRectTileShader.prototype = Object.create(PIXI.Shader.prototype);\r\nRectTileShader.prototype.constructor = RectTileShader;\r\nRectTileShader.prototype.createVao = function (renderer, vb) {\r\n    var gl = renderer.gl;\r\n    return renderer.createVao()\r\n        .addIndex(this.indexBuffer)\r\n        .addAttribute(vb, this.attributes.aVertexPosition, gl.FLOAT, false, this.stride, 0)\r\n        .addAttribute(vb, this.attributes.aTextureCoord, gl.FLOAT, false, this.stride, 2 * 4)\r\n        .addAttribute(vb, this.attributes.aFrame, gl.FLOAT, false, this.stride, 4 * 4)\r\n        .addAttribute(vb, this.attributes.aAnim, gl.FLOAT, false, this.stride, 8 * 4)\r\n        .addAttribute(vb, this.attributes.aTextureId, gl.FLOAT, false, this.stride, 10 * 4);\r\n};\r\n\r\nmodule.exports = RectTileShader;\r\n\n},{\"./shaderGenerator\":10}],6:[function(require,module,exports){\nvar shaderGenerator = require('./shaderGenerator');\r\n\r\n\r\nfunction SquareTileShader(gl, maxTextures) {\r\n    PIXI.Shader.call(this, gl,\r\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\n\\nattribute vec2 aTextureCoord;\\n\\nattribute vec2 aAnim;\\n\\nattribute float aTextureId;\\n\\nattribute float aSize;\\n\\nuniform mat3 projectionMatrix;\\n\\nuniform vec2 samplerSize;\\n\\nuniform vec2 animationFrame;\\n\\nuniform float projectionScale;\\n\\nvarying vec2 vTextureCoord;\\n\\nvarying float vSize;\\n\\nvarying float vTextureId;\\n\\nvoid main(void){\\n\\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition + aSize * 0.5, 1.0)).xy, 0.0, 1.0);\\n\\n   gl_PointSize = aSize * projectionScale;\\n\\n   vTextureCoord = aTextureCoord + aAnim * animationFrame;\\n\\n   vTextureId = aTextureId;\\n\\n   vSize = aSize;\\n\\n}\\n\\n\",\r\n        shaderGenerator.generateFragmentSrc(maxTextures, \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\n\\nvarying float vSize;\\n\\nvarying float vTextureId;\\n\\nuniform vec4 shadowColor;\\n\\nuniform sampler2D uSamplers[%count%];\\n\\nuniform vec2 uSamplerSize[%count%];\\n\\nuniform vec2 pointScale;\\n\\nvoid main(void){\\n\\n   float margin = 1.0/vSize;\\n\\n   vec2 pointCoord = (gl_PointCoord - 0.5) * pointScale + 0.5;\\n\\n   vec2 clamped = vec2(clamp(pointCoord.x, 0.0, 1.0 - margin), clamp(pointCoord.y, 0.0, 1.0 - margin));\\n\\n   vec2 textureCoord = pointCoord * vSize + vTextureCoord;\\n\\n   float textureId = vTextureId;\\n\\n   vec4 color;\\n\\n   %forloop%\\n\\n   gl_FragColor = color;\\n\\n}\\n\\n\")\r\n    );\r\n    this.maxTextures = maxTextures;\r\n    this.vertSize = 8;\r\n    this.vertPerQuad = 1;\r\n    this.stride = this.vertSize * 4;\r\n    shaderGenerator.fillSamplers(this, this.maxTextures);\r\n}\r\n\r\nSquareTileShader.prototype = Object.create(PIXI.Shader.prototype);\r\nSquareTileShader.prototype.constructor = SquareTileShader;\r\nSquareTileShader.prototype.createVao = function (renderer, vb) {\r\n    var gl = renderer.gl;\r\n    return renderer.createVao()\r\n        .addIndex(this.indexBuffer)\r\n        .addAttribute(vb, this.attributes.aVertexPosition, gl.FLOAT, false, this.stride, 0)\r\n        .addAttribute(vb, this.attributes.aTextureCoord, gl.FLOAT, false, this.stride, 2 * 4)\r\n        .addAttribute(vb, this.attributes.aSize, gl.FLOAT, false, this.stride, 4 * 4)\r\n        .addAttribute(vb, this.attributes.aAnim, gl.FLOAT, false, this.stride, 5 * 4)\r\n        .addAttribute(vb, this.attributes.aTextureId, gl.FLOAT, false, this.stride, 7 * 4);\r\n};\r\n\r\nmodule.exports = SquareTileShader;\r\n\n},{\"./shaderGenerator\":10}],7:[function(require,module,exports){\nvar RectTileShader = require('./RectTileShader'),\r\n    SquareTileShader = require('./SquareTileShader'),\r\n    glCore = PIXI.glCore;\r\n\r\n/*\r\n * Renderer for square and rectangle tiles.\r\n * Squares cannot be rotated, skewed.\r\n * For container with squares, scale.x must be equals to scale.y, matrix.a to matrix.d\r\n * Rectangles do not care about that.\r\n *\r\n * @class\r\n * @memberof PIXI.tilemap\r\n * @extends PIXI.ObjectRenderer\r\n * @param renderer {PIXI.WebGLRenderer} The renderer this sprite batch works for.\r\n */\r\n\r\nfunction TileRenderer(renderer) {\r\n    PIXI.ObjectRenderer.call(this, renderer);\r\n    this.vbs = {};\r\n    this.lastTimeCheck = 0;\r\n    this.tileAnim = [0, 0];\r\n    this.maxTextures = 4;\r\n    this.indices = [];\r\n    this.indexBuffer = null;\r\n}\r\n\r\nTileRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\r\nTileRenderer.prototype.constructor = TileRenderer;\r\nTileRenderer.vbAutoincrement = 0;\r\nTileRenderer.SCALE_MODE = PIXI.SCALE_MODES.DEFAULT;\r\n\r\nTileRenderer.prototype.onContextChange = function () {\r\n    var gl = this.renderer.gl;\r\n    var maxTextures = this.maxTextures;\r\n    this.rectShader = new RectTileShader(gl, maxTextures);\r\n    this.squareShader = new SquareTileShader(gl, maxTextures);\r\n    this.checkIndexBuffer(2000);\r\n    this.rectShader.indexBuffer = this.indexBuffer;\r\n    this.squareShader.indexBuffer = this.indexBuffer;\r\n    this.vbs = {};\r\n    this.glTextures = [];\r\n    this.boundSprites = [];\r\n    this.initBounds();\r\n};\r\n\r\nTileRenderer.prototype.initBounds = function () {\r\n    var gl = this.renderer.gl;\r\n    var tempCanvas = document.createElement('canvas');\r\n    tempCanvas.width = 2048;\r\n    tempCanvas.height = 2048;\r\n    // tempCanvas.getContext('2d').clearRect(0, 0, 2048, 2048);\r\n    for (var i = 0; i < this.maxTextures; i++) {\r\n        var glt = new glCore.GLTexture(gl, 2048, 2048);\r\n        glt.premultiplyAlpha = true;\r\n        glt.upload(tempCanvas);\r\n        glt.enableWrapClamp();\r\n\r\n        if (TileRenderer.SCALE_MODE === PIXI.SCALE_MODES.LINEAR) {\r\n            glt.enableLinearScaling();\r\n        } else {\r\n            glt.enableNearestScaling();\r\n        }\r\n\r\n        this.glTextures.push(glt);\r\n        var bs = [];\r\n        for (var j = 0; j < 4; j++) {\r\n            var spr = new PIXI.Sprite();\r\n            spr.position.x = 1024 * (j & 1);\r\n            spr.position.y = 1024 * (j >> 1);\r\n            bs.push(spr);\r\n        }\r\n        this.boundSprites.push(bs);\r\n    }\r\n};\r\n\r\nglCore.GLTexture.prototype._hackSubImage = function (sprite) {\r\n    this.bind();\r\n    var gl = this.gl;\r\n    var baseTex = sprite.texture.baseTexture;\r\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);\r\n    gl.texSubImage2D(gl.TEXTURE_2D, 0, sprite.position.x, sprite.position.y, this.format, this.type, baseTex.source);\r\n};\r\n\r\nTileRenderer.prototype.bindTextures = function (renderer, textures) {\r\n    var bounds = this.boundSprites;\r\n    var glts = this.glTextures;\r\n    var len = textures.length;\r\n    var maxTextures = this.maxTextures;\r\n    if (len >= 4 * maxTextures) {\r\n        return;\r\n    }\r\n    var i;\r\n    for (i = 0; i < len; i++) {\r\n        var texture = textures[i];\r\n        renderer.bindTexture(texture);\r\n        if (!texture || !textures[i].valid) continue;\r\n        var bs = bounds[i >> 2][i & 3];\r\n        if (!bs.texture ||\r\n            bs.texture.baseTexture !== texture.baseTexture) {\r\n            bs.texture = texture;\r\n            var glt = glts[i >> 2];\r\n            glt._hackSubImage(bs);\r\n        }\r\n    }\r\n    for (i = 0; i < maxTextures; i++) {\r\n        glts[i].bind(i);\r\n    }\r\n    renderer._activeTextureLocation = maxTextures - 1;\r\n};\r\n\r\nTileRenderer.prototype.checkLeaks = function () {\r\n    var now = Date.now();\r\n    var old = now - 10000;\r\n    if (this.lastTimeCheck < old ||\r\n        this.lastTimeCheck > now) {\r\n        this.lastTimeCheck = now;\r\n        var vbs = this.vbs;\r\n        for (var key in vbs) {\r\n            if (vbs[key].lastTimeAccess < old) {\r\n                this.removeVb(key);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nTileRenderer.prototype.start = function () {\r\n    this.renderer.state.setBlendMode(PIXI.BLEND_MODES.NORMAL);\r\n    //sorry, nothing\r\n};\r\n\r\nTileRenderer.prototype.getVb = function (id) {\r\n    this.checkLeaks();\r\n    var vb = this.vbs[id];\r\n    if (vb) {\r\n        vb.lastAccessTime = Date.now();\r\n        return vb;\r\n    }\r\n    return null;\r\n};\r\n\r\nTileRenderer.prototype.createVb = function (useSquare) {\r\n    var id = ++TileRenderer.vbAutoincrement;\r\n    var shader = this.getShader(useSquare);\r\n    var gl = this.renderer.gl;\r\n    var vb = PIXI.glCore.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);\r\n    var stuff = {\r\n        id: id,\r\n        vb: vb,\r\n        vao: shader.createVao(this.renderer, vb),\r\n        lastTimeAccess: Date.now(),\r\n        useSquare: useSquare,\r\n        shader: shader\r\n    };\r\n    this.vbs[id] = stuff;\r\n    return stuff;\r\n};\r\n\r\nTileRenderer.prototype.removeVb = function (id) {\r\n    if (this.vbs[id]) {\r\n        this.vbs[id].vb.destroy();\r\n        this.vbs[id].vao.destroy();\r\n        delete this.vbs[id];\r\n    }\r\n};\r\n\r\nTileRenderer.prototype.checkIndexBuffer = function (size) {\r\n    // the total number of indices in our array, there are 6 points per quad.\r\n    var totalIndices = size * 6;\r\n    var indices = this.indices;\r\n    if (totalIndices <= indices.length) {\r\n        return;\r\n    }\r\n    var len = indices.length || totalIndices;\r\n    while (len < totalIndices) {\r\n        len <<= 1;\r\n    }\r\n\r\n    indices = new Uint16Array(len);\r\n    this.indices = indices;\r\n\r\n    // fill the indices with the quads to draw\r\n    for (var i = 0, j = 0; i + 5 < indices.length; i += 6, j += 4) {\r\n        indices[i + 0] = j + 0;\r\n        indices[i + 1] = j + 1;\r\n        indices[i + 2] = j + 2;\r\n        indices[i + 3] = j + 0;\r\n        indices[i + 4] = j + 2;\r\n        indices[i + 5] = j + 3;\r\n    }\r\n\r\n    if (this.indexBuffer) {\r\n        this.indexBuffer.upload(indices);\r\n    } else {\r\n        var gl = this.renderer.gl;\r\n        this.indexBuffer = glCore.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);\r\n    }\r\n};\r\n\r\nTileRenderer.prototype.getShader = function (useSquare) {\r\n    return useSquare ? this.squareShader : this.rectShader;\r\n};\r\n\r\nTileRenderer.prototype.destroy = function () {\r\n    PIXI.ObjectRenderer.prototype.destroy.call(this);\r\n    this.rectShader.destroy();\r\n    this.squareShader.destroy();\r\n    this.rectShader = null;\r\n    this.squareShader = null;\r\n};\r\n\r\nPIXI.WebGLRenderer.registerPlugin('tile', TileRenderer);\r\n\r\nmodule.exports = TileRenderer;\r\n\n},{\"./RectTileShader\":5,\"./SquareTileShader\":6}],8:[function(require,module,exports){\nfunction ZLayer() {\r\n    this.initialize.apply(this, arguments);\r\n}\r\n\r\nZLayer.prototype = Object.create(PIXI.Container.prototype);\r\nZLayer.prototype.initialize = function(tilemap, zIndex) {\r\n    PIXI.Container.apply(this, arguments);\r\n    this.tilemap = tilemap;\r\n    this.z = zIndex;\r\n};\r\n\r\nZLayer.prototype.clear = function() {\r\n    var layers = this.children;\r\n    for (var i=0; i<layers.length; i++)\r\n        layers[i].clear();\r\n    this._previousLayers = 0;\r\n};\r\n\r\nZLayer.prototype.cacheIfDirty = function() {\r\n    var tilemap = this.tilemap;\r\n    var layers = this.children;\r\n    var modified = this._previousLayers != layers.length;\r\n    this._previousLayers = layers.length;\r\n    var buf = this.canvasBuffer;\r\n    var tempRender = this._tempRender;\r\n    if (!buf) {\r\n        buf = this.canvasBuffer = document.createElement('canvas');\r\n        tempRender = this._tempRender = new PIXI.CanvasRenderer(100, 100, { view: buf });\r\n        tempRender.context = tempRender.rootContext;\r\n        tempRender.dontUseTransform = true;\r\n    }\r\n    if (buf.width != tilemap._layerWidth ||\r\n        buf.height != tilemap._layerHeight) {\r\n        buf.width = tilemap._layerWidth;\r\n        buf.height = tilemap._layerHeight;\r\n        modified = true;\r\n    }\r\n    var i;\r\n    if (!modified) {\r\n        for (i=0;i<layers.length;i++) {\r\n            if (layers[i].isModified(this._lastAnimationFrame != tilemap.animationFrame)) {\r\n                modified = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    this._lastAnimationFrame = tilemap.animationFrame;\r\n    if (modified) {\r\n        if (tilemap._hackRenderer) {\r\n            tilemap._hackRenderer(tempRender);\r\n        }\r\n        tempRender.context.clearRect(0, 0, buf.width, buf.height);\r\n        for (i=0;i<layers.length;i++) {\r\n            layers[i].clearModify();\r\n            layers[i].renderCanvas(tempRender);\r\n        }\r\n    }\r\n    this.layerTransform = this.worldTransform;\r\n    for (i=0;i<layers.length;i++) {\r\n        this.layerTransform = layers[i].worldTransform;\r\n        break;\r\n    }\r\n};\r\n\r\nZLayer.prototype.renderCanvas = function(renderer) {\r\n    this.cacheIfDirty();\r\n    var wt = this.layerTransform;\r\n    renderer.context.setTransform(\r\n        wt.a,\r\n        wt.b,\r\n        wt.c,\r\n        wt.d,\r\n        wt.tx * renderer.resolution,\r\n        wt.ty * renderer.resolution\r\n    );\r\n    var tilemap = this.tilemap;\r\n    renderer.context.drawImage(this.canvasBuffer, 0, 0);\r\n};\r\n\r\nmodule.exports = ZLayer;\r\n\n},{}],9:[function(require,module,exports){\nPIXI.tilemap = {\r\n    ZLayer: require('./ZLayer'),\r\n    GraphicsLayer: require('./GraphicsLayer'),\r\n    RectTileLayer: require('./RectTileLayer'),\r\n    CompositeRectTileLayer: require('./CompositeRectTileLayer'),\r\n    CanvasTileRenderer: require('./CanvasTileRenderer'),\r\n    TileRenderer: require('./TileRenderer')\r\n};\r\n\r\nmodule.exports = PIXI.tilemap;\r\n\n},{\"./CanvasTileRenderer\":1,\"./CompositeRectTileLayer\":2,\"./GraphicsLayer\":3,\"./RectTileLayer\":4,\"./TileRenderer\":7,\"./ZLayer\":8}],10:[function(require,module,exports){\nvar shaderGenerator = {\r\n    fillSamplers: function(shader, maxTextures) {\r\n        var sampleValues = [];\r\n        for (var i = 0; i < maxTextures; i++)\r\n        {\r\n            sampleValues[i] = i;\r\n        }\r\n        shader.bind();\r\n        shader.uniforms.uSamplers = sampleValues;\r\n\r\n        var samplerSize = [];\r\n        for (i = 0; i < maxTextures; i++) {\r\n            samplerSize.push(1.0 / 2048);\r\n            samplerSize.push(1.0 / 2048);\r\n        }\r\n        shader.uniforms.uSamplerSize = samplerSize;\r\n    },\r\n    generateFragmentSrc: function(maxTextures, fragmentSrc) {\r\n        return fragmentSrc.replace(/%count%/gi, maxTextures)\r\n            .replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));\r\n    },\r\n    generateSampleSrc: function(maxTextures) {\r\n        var src = '';\r\n\r\n        src += '\\n';\r\n        src += '\\n';\r\n\r\n        src += 'if(vTextureId <= -1.0) {';\r\n        src += '\\n\\tcolor = shadowColor;';\r\n        src += '\\n}';\r\n\r\n        for (var i = 0; i < maxTextures; i++)\r\n        {\r\n            src += '\\nelse ';\r\n\r\n            if(i < maxTextures-1)\r\n            {\r\n                src += 'if(textureId == ' + i + '.0)';\r\n            }\r\n\r\n            src += '\\n{';\r\n            src += '\\n\\tcolor = texture2D(uSamplers['+i+'], textureCoord * uSamplerSize['+i+']);';\r\n            src += '\\n}';\r\n        }\r\n\r\n        src += '\\n';\r\n        src += '\\n';\r\n\r\n        return src;\r\n    }\r\n};\r\n\r\nmodule.exports = shaderGenerator;\r\n\n},{}]},{},[9])\n\n","var RectTileLayer = require('./RectTileLayer');\r\n\r\nfunction CompositeRectTileLayer() {\r\n    PIXI.Container.apply(this, arguments);\r\n    this.initialize.apply(this, arguments);\r\n}\r\n\r\nCompositeRectTileLayer.prototype = Object.create(PIXI.Container.prototype);\r\nCompositeRectTileLayer.prototype.constructor = RectTileLayer;\r\nCompositeRectTileLayer.prototype.updateTransform = CompositeRectTileLayer.prototype.displayObjectUpdateTransform;\r\n\r\n//can be initialized multiple times\r\nCompositeRectTileLayer.prototype.initialize = function (zIndex, bitmaps, useSquare, texPerChild) {\r\n    this.z = this.zIndex = zIndex;\r\n    this.useSquare = useSquare;\r\n    this.shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\r\n    this.texPerChild = texPerChild || 16;\r\n    if (bitmaps) {\r\n        this.setBitmaps(bitmaps);\r\n    }\r\n};\r\n\r\nCompositeRectTileLayer.prototype.setBitmaps = function (bitmaps) {\r\n    var texPerChild = this.texPerChild;\r\n    var len1 = this.children.length;\r\n    var len2 = Math.ceil(bitmaps.length / texPerChild);\r\n    var i;\r\n    for (i = 0; i < len1; i++) {\r\n        this.children[i].textures = bitmaps.slice(i * texPerChild, (i + 1) * texPerChild);\r\n    }\r\n    for (i = len1; i < len2; i++) {\r\n        this.addChild(new RectTileLayer(this.zIndex, bitmaps.slice(i * texPerChild, (i + 1) * texPerChild)));\r\n    }\r\n};\r\n\r\nCompositeRectTileLayer.prototype.clear = function () {\r\n    for (var i = 0; i < this.children.length; i++)\r\n        this.children[i].clear();\r\n    this.modificationMarker = 0;\r\n};\r\n\r\nCompositeRectTileLayer.prototype.addRect = function (num, u, v, x, y, tileWidth, tileHeight) {\r\n    if (this.children[num] && this.children[num].textures)\r\n        this.children[num].addRect(0, u, v, x, y, tileWidth, tileHeight);\r\n};\r\n\r\n/**\r\n * \"hello world!\" of pixi-tilemap library. Pass it texture and it will be added\r\n * @param texture\r\n * @param x\r\n * @param y\r\n * @returns {boolean}\r\n */\r\nCompositeRectTileLayer.prototype.addFrame = function (texture, x, y) {\r\n    if (typeof texture === \"string\") {\r\n        texture = PIXI.Texture.fromImage(texture);\r\n    }\r\n    var children = this.children;\r\n    var layer = null, ind = 0;\r\n    for (var i = 0; i < children.length; i++) {\r\n        var tex = children[i].textures;\r\n        for (var j = 0; j < tex.length; j++) {\r\n            if (tex[j].baseTexture == texture.baseTexture) {\r\n                layer = children[i];\r\n                ind = j;\r\n                break;\r\n            }\r\n        }\r\n        if (layer) {\r\n            break;\r\n        }\r\n    }\r\n    if (!layer) {\r\n        for (i = 0; i < children.length; i++) {\r\n            var child = children[i];\r\n            if (child.textures.length < 16) {\r\n                layer = child;\r\n                ind = child.textures.length;\r\n                child.textures.push(texture);\r\n            }\r\n        }\r\n        if (!layer) {\r\n            children.push(layer = new RectTileLayer(this.zIndex, texture));\r\n            ind = 0;\r\n        }\r\n    }\r\n    layer.addRect(ind, texture.frame.x, texture.frame.y, x, y, texture.frame.width, texture.frame.height);\r\n    return true;\r\n};\r\n\r\nCompositeRectTileLayer.prototype.renderCanvas = function (renderer) {\r\n    if (!renderer.dontUseTransform) {\r\n        var wt = this.worldTransform;\r\n        renderer.context.setTransform(\r\n            wt.a,\r\n            wt.b,\r\n            wt.c,\r\n            wt.d,\r\n            wt.tx * renderer.resolution,\r\n            wt.ty * renderer.resolution\r\n        );\r\n    }\r\n    var layers = this.children;\r\n    for (var i = 0; i < layers.length; i++)\r\n        layers[i].renderCanvas(renderer);\r\n};\r\n\r\n\r\nCompositeRectTileLayer.prototype.renderWebGL = function (renderer) {\r\n    var gl = renderer.gl;\r\n    var shader = renderer.plugins.tile.getShader(this.useSquare);\r\n    renderer.setObjectRenderer(renderer.plugins.tile);\r\n    renderer.bindShader(shader);\r\n    //TODO: dont create new array, please\r\n    this._globalMat = this._globalMat || new PIXI.Matrix();\r\n    renderer._activeRenderTarget.projectionMatrix.copy(this._globalMat).append(this.worldTransform);\r\n    shader.uniforms.projectionMatrix = this._globalMat.toArray(true);\r\n    shader.uniforms.shadowColor = this.shadowColor;\r\n    if (this.useSquare) {\r\n        var tempScale = this._tempScale = (this._tempScale || [0, 0]);\r\n        tempScale[0] = this._globalMat.a >= 0 ? 1 : -1;\r\n        tempScale[1] = this._globalMat.d < 0 ? 1 : -1;\r\n        var ps = shader.uniforms.pointScale = tempScale;\r\n        shader.uniforms.projectionScale = Math.abs(this.worldTransform.a) * renderer.resolution;\r\n    }\r\n    var af = shader.uniforms.animationFrame = renderer.plugins.tile.tileAnim;\r\n    //shader.syncUniform(shader.uniforms.animationFrame);\r\n    var layers = this.children;\r\n    for (var i = 0; i < layers.length; i++)\r\n        layers[i].renderWebGL(renderer, this.useSquare);\r\n};\r\n\r\n\r\nCompositeRectTileLayer.prototype.isModified = function (anim) {\r\n    var layers = this.children;\r\n    if (this.modificationMarker != layers.length) {\r\n        return true;\r\n    }\r\n    for (var i = 0; i < layers.length; i++) {\r\n        if (layers[i].modificationMarker != layers[i].pointsBuf.length ||\r\n            anim && layers[i].hasAnim) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nCompositeRectTileLayer.prototype.clearModify = function () {\r\n    var layers = this.children;\r\n    this.modificationMarker = layers.length;\r\n    for (var i = 0; i < layers.length; i++) {\r\n        layers[i].modificationMarker = layers[i].pointsBuf.length;\r\n    }\r\n};\r\n\r\nmodule.exports = CompositeRectTileLayer;\r\n","function GraphicsLayer(zIndex) {\r\n    PIXI.Graphics.apply(this, arguments);\r\n    this.z = this.zIndex = zIndex;\r\n}\r\n\r\nGraphicsLayer.prototype = Object.create(PIXI.Graphics.prototype);\r\nGraphicsLayer.prototype.constructor = GraphicsLayer;\r\nGraphicsLayer.prototype.renderCanvas = function (renderer) {\r\n    var wt = null;\r\n    if (renderer.dontUseTransform) {\r\n        wt = this.transform.worldTransform;\r\n        this.transform.worldTransform = PIXI.Matrix.IDENTITY;\r\n    }\r\n    renderer.plugins.graphics.render(this);\r\n    if (renderer.dontUseTransform) {\r\n        this.transform.worldTransform = wt;\r\n    }\r\n    renderer.context.globalAlpha = 1.0;\r\n};\r\nGraphicsLayer.prototype.renderWebGL = function(renderer) {\r\n    if (!this._webGL[renderer.gl.id])\r\n        this.dirty = true;\r\n    PIXI.Graphics.prototype.renderWebGL.call(this, renderer);\r\n};\r\n\r\nGraphicsLayer.prototype.isModified = function(anim) {\r\n    return false;\r\n};\r\n\r\nGraphicsLayer.prototype.clearModify = function() {\r\n};\r\n\r\nmodule.exports = GraphicsLayer;\r\n","function RectTileLayer(zIndex, texture) {\r\n    PIXI.DisplayObject.apply(this, arguments);\r\n    this.initialize.apply(this, arguments);\r\n}\r\n\r\nRectTileLayer.prototype = Object.create(PIXI.DisplayObject.prototype);\r\nRectTileLayer.prototype.constructor = RectTileLayer;\r\n\r\nRectTileLayer.prototype.initialize = function(zIndex, textures) {\r\n    if (!textures) {\r\n        textures = [];\r\n    } else if (!(textures instanceof Array) && textures.baseTexture) {\r\n        textures = [textures];\r\n    }\r\n    this.textures = textures;\r\n    this.z = this.zIndex = zIndex;\r\n    this.pointsBuf = [];\r\n    this.visible = false;\r\n    this._tempSize = new Float32Array([0, 0]);\r\n    this._tempTexSize = 1;\r\n};\r\n\r\nRectTileLayer.prototype.clear = function () {\r\n    this.pointsBuf.length = 0;\r\n    this.modificationMarker = 0;\r\n    this.hasAnim = false;\r\n};\r\n\r\nRectTileLayer.prototype.renderCanvas = function (renderer) {\r\n    if (this.textures.length === 0) return;\r\n    var points = this.pointsBuf;\r\n    renderer.context.fillStyle = '#000000';\r\n    for (var i = 0, n = points.length; i < n; i += 9) {\r\n        var x1 = points[i], y1 = points[i+1];\r\n        var x2 = points[i+2], y2 = points[i+3];\r\n        var w = points[i+4];\r\n        var h = points[i+5];\r\n        x1 += points[i+6] * renderer.plugins.tile.tileAnim[0];\r\n        y1 += points[i+7] * renderer.plugins.tile.tileAnim[1];\r\n        var textureId = points[i+8];\r\n        if (textureId >= 0) {\r\n            renderer.context.drawImage(this.textures[textureId].baseTexture.source, x1, y1, w, h, x2, y2, w, h);\r\n        } else {\r\n            renderer.context.globalAlpha = 0.5;\r\n            renderer.context.fillRect(x2, y2, w, h);\r\n            renderer.context.globalAlpha = 1;\r\n        }\r\n    }\r\n};\r\n\r\nRectTileLayer.prototype.addRect = function (textureId, u, v, x, y, tileWidth, tileHeight, animX, animY) {\r\n    var pb = this.pointsBuf;\r\n    this.hasAnim = this.hasAnim || animX > 0 || animY > 0;\r\n    if (tileWidth == tileHeight) {\r\n        pb.push(u);\r\n        pb.push(v);\r\n        pb.push(x);\r\n        pb.push(y);\r\n        pb.push(tileWidth);\r\n        pb.push(tileHeight);\r\n        pb.push(animX | 0);\r\n        pb.push(animY | 0);\r\n        pb.push(textureId);\r\n    } else {\r\n        var i;\r\n        if (tileWidth % tileHeight === 0) {\r\n            //horizontal line on squares\r\n            for (i=0;i<tileWidth/tileHeight;i++) {\r\n                pb.push(u + i * tileHeight);\r\n                pb.push(v);\r\n                pb.push(x + i * tileHeight);\r\n                pb.push(y);\r\n                pb.push(tileHeight);\r\n                pb.push(tileHeight);\r\n                pb.push(animX | 0);\r\n                pb.push(animY | 0);\r\n                pb.push(textureId);\r\n            }\r\n        } else if (tileHeight % tileWidth === 0) {\r\n            //vertical line on squares\r\n            for (i=0;i<tileHeight/tileWidth;i++) {\r\n                pb.push(u);\r\n                pb.push(v + i * tileWidth);\r\n                pb.push(x);\r\n                pb.push(y + i * tileWidth);\r\n                pb.push(tileWidth);\r\n                pb.push(tileWidth);\r\n                pb.push(animX | 0);\r\n                pb.push(animY | 0);\r\n                pb.push(textureId);\r\n            }\r\n        } else {\r\n            //ok, ok, lets use rectangle. but its not working with square shader yet\r\n            pb.push(u);\r\n            pb.push(v);\r\n            pb.push(x);\r\n            pb.push(y);\r\n            pb.push(tileWidth);\r\n            pb.push(tileHeight);\r\n            pb.push(animX | 0);\r\n            pb.push(animY | 0);\r\n            pb.push(textureId);\r\n        }\r\n    }\r\n};\r\n\r\nRectTileLayer.prototype.renderWebGL = function(renderer, useSquare) {\r\n    var points = this.pointsBuf;\r\n    if (points.length === 0) return;\r\n    var rectsCount = points.length / 9;\r\n    var tile = renderer.plugins.tile;\r\n    var gl = renderer.gl;\r\n    if (!useSquare) {\r\n        tile.checkIndexBuffer(rectsCount);\r\n    }\r\n\r\n    var shader = tile.getShader(useSquare);\r\n    var textures = this.textures;\r\n    if (textures.length === 0) return;\r\n    var len = textures.length;\r\n    if (this._tempTexSize < shader.maxTextures) {\r\n        this._tempTexSize = shader.maxTextures;\r\n        this._tempSize = new Float32Array(2*shader.maxTextures);\r\n    }\r\n    // var samplerSize = this._tempSize;\r\n    for (var i=0;i<len;i++) {\r\n        if (!textures[i] || !textures[i].valid) return;\r\n        var texture = textures[i].baseTexture;\r\n        // samplerSize[i * 2] = 1.0 / texture.width;\r\n        // samplerSize[i * 2 + 1] = 1.0 / texture.height;\r\n    }\r\n    tile.bindTextures(renderer, textures);\r\n    // shader.uniforms.uSamplerSize = samplerSize;\r\n    //lost context! recover!\r\n    var vb = tile.getVb(this.vbId);\r\n    if (!vb) {\r\n        vb = tile.createVb(useSquare);\r\n        this.vbId = vb.id;\r\n        this.vbBuffer = null;\r\n        this.modificationMarker = 0;\r\n    }\r\n    var vao = vb.vao.bind();\r\n    vb = vb.vb;\r\n    //if layer was changed, re-upload vertices\r\n    vb.bind();\r\n    var vertices = rectsCount * shader.vertPerQuad;\r\n    if (vertices === 0) return;\r\n    if (this.modificationMarker != vertices) {\r\n        this.modificationMarker = vertices;\r\n        var vs = shader.stride * vertices;\r\n        if (!this.vbBuffer || this.vbBuffer.byteLength < vs) {\r\n            //!@#$ happens, need resize\r\n            var bk = shader.stride;\r\n            while (bk < vs) {\r\n                bk *= 2;\r\n            }\r\n            this.vbBuffer = new ArrayBuffer(bk);\r\n            this.vbArray = new Float32Array(this.vbBuffer);\r\n            this.vbInts = new Uint32Array(this.vbBuffer);\r\n            vb.upload(this.vbBuffer, 0, true);\r\n        }\r\n\r\n        var arr = this.vbArray, ints = this.vbInts;\r\n        //upload vertices!\r\n        var sz = 0;\r\n        //var tint = 0xffffffff;\r\n        var textureId, shiftU, shiftV;\r\n        if (useSquare) {\r\n            for (i = 0; i < points.length; i += 9) {\r\n                textureId = (points[i+8] >> 2);\r\n                shiftU = 1024 * (points[i+8] & 1);\r\n                shiftV = 1024 * ((points[i+8] >> 1) & 1);\r\n                arr[sz++] = points[i + 2];\r\n                arr[sz++] = points[i + 3];\r\n                arr[sz++] = points[i + 0] + shiftU;\r\n                arr[sz++] = points[i + 1] + shiftV;\r\n                arr[sz++] = points[i + 4];\r\n                arr[sz++] = points[i + 6];\r\n                arr[sz++] = points[i + 7];\r\n                arr[sz++] = textureId;\r\n            }\r\n        } else {\r\n            //var tint = 0xffffffff;\r\n            var tint = -1;\r\n            for (i = 0;i<points.length;i += 9) {\r\n                var eps = 0.5;\r\n                textureId = (points[i+8] >> 2);\r\n                shiftU = 1024 * (points[i+8] & 1);\r\n                shiftV = 1024 * ((points[i+8] >> 1) & 1);\r\n                var x = points[i+2], y = points[i+3];\r\n                var w = points[i+4], h = points[i+5];\r\n                var u = points[i] + shiftU, v = points[i+1] + shiftV;\r\n                var animX = points[i+6], animY = points[i+7];\r\n                arr[sz++] = x;\r\n                arr[sz++] = y;\r\n                arr[sz++] = u;\r\n                arr[sz++] = v;\r\n                arr[sz++] = u;\r\n                arr[sz++] = v ;\r\n                arr[sz++] = u + w - 2*eps;\r\n                arr[sz++] = v + h - 2*eps;\r\n                arr[sz++] = animX;\r\n                arr[sz++] = animY;\r\n                arr[sz++] = textureId;\r\n                arr[sz++] = x + w;\r\n                arr[sz++] = y;\r\n                arr[sz++] = u + w;\r\n                arr[sz++] = v;\r\n                arr[sz++] = u;\r\n                arr[sz++] = v;\r\n                arr[sz++] = u + w - 2*eps;\r\n                arr[sz++] = v + h - 2*eps;\r\n                arr[sz++] = animX;\r\n                arr[sz++] = animY;\r\n                arr[sz++] = textureId;\r\n                arr[sz++] = x + w;\r\n                arr[sz++] = y + h;\r\n                arr[sz++] = u + w;\r\n                arr[sz++] = v + h;\r\n                arr[sz++] = u;\r\n                arr[sz++] = v;\r\n                arr[sz++] = u + w - 2*eps;\r\n                arr[sz++] = v + h - 2*eps;\r\n                arr[sz++] = animX;\r\n                arr[sz++] = animY;\r\n                arr[sz++] = textureId;\r\n                arr[sz++] = x;\r\n                arr[sz++] = y + h;\r\n                arr[sz++] = u;\r\n                arr[sz++] = v + h;\r\n                arr[sz++] = u;\r\n                arr[sz++] = v;\r\n                arr[sz++] = u + w - 2*eps;\r\n                arr[sz++] = v + h - 2*eps;\r\n                arr[sz++] = animX;\r\n                arr[sz++] = animY;\r\n                arr[sz++] = textureId;\r\n            }\r\n        }\r\n        // if (vs > this.vbArray.length/2 ) {\r\n        vb.upload(arr, 0, true);\r\n        // } else {\r\n        //     var view = arr.subarray(0, vs);\r\n        //     vb.upload(view, 0);\r\n        // }\r\n    }\r\n    if (useSquare)\r\n        gl.drawArrays(gl.POINTS, 0, vertices);\r\n    else\r\n        gl.drawElements(gl.TRIANGLES, rectsCount * 6, gl.UNSIGNED_SHORT, 0);\r\n};\r\n\r\nmodule.exports = RectTileLayer;\r\n","var shaderGenerator = require('./shaderGenerator');\r\n\r\nfunction RectTileShader(gl, maxTextures)\r\n{\r\n    PIXI.Shader.call(this, gl,\r\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\n\\nattribute vec2 aTextureCoord;\\n\\nattribute vec4 aFrame;\\n\\nattribute vec2 aAnim;\\n\\nattribute float aTextureId;\\n\\nuniform mat3 projectionMatrix;\\n\\nuniform vec2 animationFrame;\\n\\nvarying vec2 vTextureCoord;\\n\\nvarying float vTextureId;\\n\\nvarying vec4 vFrame;\\n\\nvoid main(void){\\n\\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n   vec2 anim = aAnim * animationFrame;\\n\\n   vTextureCoord = aTextureCoord + anim;\\n\\n   vFrame = aFrame + vec4(anim, anim);\\n\\n   vTextureId = aTextureId;\\n\\n}\\n\\n\",\r\n        shaderGenerator.generateFragmentSrc(maxTextures, \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\n\\nvarying vec4 vFrame;\\n\\nvarying float vTextureId;\\n\\nuniform vec4 shadowColor;\\n\\nuniform sampler2D uSamplers[%count%];\\n\\nuniform vec2 uSamplerSize[%count%];\\n\\nvoid main(void){\\n\\n   vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\\n\\n   float textureId = floor(vTextureId + 0.5);\\n\\n   vec4 color;\\n\\n   %forloop%\\n\\n   gl_FragColor = color;\\n\\n}\\n\\n\")\r\n    );\r\n    this.maxTextures = maxTextures;\r\n    this.vertSize = 11;\r\n    this.vertPerQuad = 4;\r\n    this.stride = this.vertSize * 4;\r\n    shaderGenerator.fillSamplers(this, this.maxTextures);\r\n}\r\n\r\nRectTileShader.prototype = Object.create(PIXI.Shader.prototype);\r\nRectTileShader.prototype.constructor = RectTileShader;\r\nRectTileShader.prototype.createVao = function (renderer, vb) {\r\n    var gl = renderer.gl;\r\n    return renderer.createVao()\r\n        .addIndex(this.indexBuffer)\r\n        .addAttribute(vb, this.attributes.aVertexPosition, gl.FLOAT, false, this.stride, 0)\r\n        .addAttribute(vb, this.attributes.aTextureCoord, gl.FLOAT, false, this.stride, 2 * 4)\r\n        .addAttribute(vb, this.attributes.aFrame, gl.FLOAT, false, this.stride, 4 * 4)\r\n        .addAttribute(vb, this.attributes.aAnim, gl.FLOAT, false, this.stride, 8 * 4)\r\n        .addAttribute(vb, this.attributes.aTextureId, gl.FLOAT, false, this.stride, 10 * 4);\r\n};\r\n\r\nmodule.exports = RectTileShader;\r\n","var shaderGenerator = require('./shaderGenerator');\r\n\r\n\r\nfunction SquareTileShader(gl, maxTextures) {\r\n    PIXI.Shader.call(this, gl,\r\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\n\\nattribute vec2 aTextureCoord;\\n\\nattribute vec2 aAnim;\\n\\nattribute float aTextureId;\\n\\nattribute float aSize;\\n\\nuniform mat3 projectionMatrix;\\n\\nuniform vec2 samplerSize;\\n\\nuniform vec2 animationFrame;\\n\\nuniform float projectionScale;\\n\\nvarying vec2 vTextureCoord;\\n\\nvarying float vSize;\\n\\nvarying float vTextureId;\\n\\nvoid main(void){\\n\\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition + aSize * 0.5, 1.0)).xy, 0.0, 1.0);\\n\\n   gl_PointSize = aSize * projectionScale;\\n\\n   vTextureCoord = aTextureCoord + aAnim * animationFrame;\\n\\n   vTextureId = aTextureId;\\n\\n   vSize = aSize;\\n\\n}\\n\\n\",\r\n        shaderGenerator.generateFragmentSrc(maxTextures, \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\n\\nvarying float vSize;\\n\\nvarying float vTextureId;\\n\\nuniform vec4 shadowColor;\\n\\nuniform sampler2D uSamplers[%count%];\\n\\nuniform vec2 uSamplerSize[%count%];\\n\\nuniform vec2 pointScale;\\n\\nvoid main(void){\\n\\n   float margin = 1.0/vSize;\\n\\n   vec2 pointCoord = (gl_PointCoord - 0.5) * pointScale + 0.5;\\n\\n   vec2 clamped = vec2(clamp(pointCoord.x, 0.0, 1.0 - margin), clamp(pointCoord.y, 0.0, 1.0 - margin));\\n\\n   vec2 textureCoord = pointCoord * vSize + vTextureCoord;\\n\\n   float textureId = vTextureId;\\n\\n   vec4 color;\\n\\n   %forloop%\\n\\n   gl_FragColor = color;\\n\\n}\\n\\n\")\r\n    );\r\n    this.maxTextures = maxTextures;\r\n    this.vertSize = 8;\r\n    this.vertPerQuad = 1;\r\n    this.stride = this.vertSize * 4;\r\n    shaderGenerator.fillSamplers(this, this.maxTextures);\r\n}\r\n\r\nSquareTileShader.prototype = Object.create(PIXI.Shader.prototype);\r\nSquareTileShader.prototype.constructor = SquareTileShader;\r\nSquareTileShader.prototype.createVao = function (renderer, vb) {\r\n    var gl = renderer.gl;\r\n    return renderer.createVao()\r\n        .addIndex(this.indexBuffer)\r\n        .addAttribute(vb, this.attributes.aVertexPosition, gl.FLOAT, false, this.stride, 0)\r\n        .addAttribute(vb, this.attributes.aTextureCoord, gl.FLOAT, false, this.stride, 2 * 4)\r\n        .addAttribute(vb, this.attributes.aSize, gl.FLOAT, false, this.stride, 4 * 4)\r\n        .addAttribute(vb, this.attributes.aAnim, gl.FLOAT, false, this.stride, 5 * 4)\r\n        .addAttribute(vb, this.attributes.aTextureId, gl.FLOAT, false, this.stride, 7 * 4);\r\n};\r\n\r\nmodule.exports = SquareTileShader;\r\n","var RectTileShader = require('./RectTileShader'),\r\n    SquareTileShader = require('./SquareTileShader'),\r\n    glCore = PIXI.glCore;\r\n\r\n/*\r\n * Renderer for square and rectangle tiles.\r\n * Squares cannot be rotated, skewed.\r\n * For container with squares, scale.x must be equals to scale.y, matrix.a to matrix.d\r\n * Rectangles do not care about that.\r\n *\r\n * @class\r\n * @memberof PIXI.tilemap\r\n * @extends PIXI.ObjectRenderer\r\n * @param renderer {PIXI.WebGLRenderer} The renderer this sprite batch works for.\r\n */\r\n\r\nfunction TileRenderer(renderer) {\r\n    PIXI.ObjectRenderer.call(this, renderer);\r\n    this.vbs = {};\r\n    this.lastTimeCheck = 0;\r\n    this.tileAnim = [0, 0];\r\n    this.maxTextures = 4;\r\n    this.indices = [];\r\n    this.indexBuffer = null;\r\n}\r\n\r\nTileRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\r\nTileRenderer.prototype.constructor = TileRenderer;\r\nTileRenderer.vbAutoincrement = 0;\r\nTileRenderer.SCALE_MODE = PIXI.SCALE_MODES.DEFAULT;\r\n\r\nTileRenderer.prototype.onContextChange = function () {\r\n    var gl = this.renderer.gl;\r\n    var maxTextures = this.maxTextures;\r\n    this.rectShader = new RectTileShader(gl, maxTextures);\r\n    this.squareShader = new SquareTileShader(gl, maxTextures);\r\n    this.checkIndexBuffer(2000);\r\n    this.rectShader.indexBuffer = this.indexBuffer;\r\n    this.squareShader.indexBuffer = this.indexBuffer;\r\n    this.vbs = {};\r\n    this.glTextures = [];\r\n    this.boundSprites = [];\r\n    this.initBounds();\r\n};\r\n\r\nTileRenderer.prototype.initBounds = function () {\r\n    var gl = this.renderer.gl;\r\n    var tempCanvas = document.createElement('canvas');\r\n    tempCanvas.width = 2048;\r\n    tempCanvas.height = 2048;\r\n    // tempCanvas.getContext('2d').clearRect(0, 0, 2048, 2048);\r\n    for (var i = 0; i < this.maxTextures; i++) {\r\n        var glt = new glCore.GLTexture(gl, 2048, 2048);\r\n        glt.premultiplyAlpha = true;\r\n        glt.upload(tempCanvas);\r\n        glt.enableWrapClamp();\r\n\r\n        if (TileRenderer.SCALE_MODE === PIXI.SCALE_MODES.LINEAR) {\r\n            glt.enableLinearScaling();\r\n        } else {\r\n            glt.enableNearestScaling();\r\n        }\r\n\r\n        this.glTextures.push(glt);\r\n        var bs = [];\r\n        for (var j = 0; j < 4; j++) {\r\n            var spr = new PIXI.Sprite();\r\n            spr.position.x = 1024 * (j & 1);\r\n            spr.position.y = 1024 * (j >> 1);\r\n            bs.push(spr);\r\n        }\r\n        this.boundSprites.push(bs);\r\n    }\r\n};\r\n\r\nglCore.GLTexture.prototype._hackSubImage = function (sprite) {\r\n    this.bind();\r\n    var gl = this.gl;\r\n    var baseTex = sprite.texture.baseTexture;\r\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);\r\n    gl.texSubImage2D(gl.TEXTURE_2D, 0, sprite.position.x, sprite.position.y, this.format, this.type, baseTex.source);\r\n};\r\n\r\nTileRenderer.prototype.bindTextures = function (renderer, textures) {\r\n    var bounds = this.boundSprites;\r\n    var glts = this.glTextures;\r\n    var len = textures.length;\r\n    var maxTextures = this.maxTextures;\r\n    if (len >= 4 * maxTextures) {\r\n        return;\r\n    }\r\n    var i;\r\n    for (i = 0; i < len; i++) {\r\n        var texture = textures[i];\r\n        renderer.bindTexture(texture);\r\n        if (!texture || !textures[i].valid) continue;\r\n        var bs = bounds[i >> 2][i & 3];\r\n        if (!bs.texture ||\r\n            bs.texture.baseTexture !== texture.baseTexture) {\r\n            bs.texture = texture;\r\n            var glt = glts[i >> 2];\r\n            glt._hackSubImage(bs);\r\n        }\r\n    }\r\n    for (i = 0; i < maxTextures; i++) {\r\n        glts[i].bind(i);\r\n    }\r\n    renderer._activeTextureLocation = maxTextures - 1;\r\n};\r\n\r\nTileRenderer.prototype.checkLeaks = function () {\r\n    var now = Date.now();\r\n    var old = now - 10000;\r\n    if (this.lastTimeCheck < old ||\r\n        this.lastTimeCheck > now) {\r\n        this.lastTimeCheck = now;\r\n        var vbs = this.vbs;\r\n        for (var key in vbs) {\r\n            if (vbs[key].lastTimeAccess < old) {\r\n                this.removeVb(key);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nTileRenderer.prototype.start = function () {\r\n    this.renderer.state.setBlendMode(PIXI.BLEND_MODES.NORMAL);\r\n    //sorry, nothing\r\n};\r\n\r\nTileRenderer.prototype.getVb = function (id) {\r\n    this.checkLeaks();\r\n    var vb = this.vbs[id];\r\n    if (vb) {\r\n        vb.lastAccessTime = Date.now();\r\n        return vb;\r\n    }\r\n    return null;\r\n};\r\n\r\nTileRenderer.prototype.createVb = function (useSquare) {\r\n    var id = ++TileRenderer.vbAutoincrement;\r\n    var shader = this.getShader(useSquare);\r\n    var gl = this.renderer.gl;\r\n    var vb = PIXI.glCore.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);\r\n    var stuff = {\r\n        id: id,\r\n        vb: vb,\r\n        vao: shader.createVao(this.renderer, vb),\r\n        lastTimeAccess: Date.now(),\r\n        useSquare: useSquare,\r\n        shader: shader\r\n    };\r\n    this.vbs[id] = stuff;\r\n    return stuff;\r\n};\r\n\r\nTileRenderer.prototype.removeVb = function (id) {\r\n    if (this.vbs[id]) {\r\n        this.vbs[id].vb.destroy();\r\n        this.vbs[id].vao.destroy();\r\n        delete this.vbs[id];\r\n    }\r\n};\r\n\r\nTileRenderer.prototype.checkIndexBuffer = function (size) {\r\n    // the total number of indices in our array, there are 6 points per quad.\r\n    var totalIndices = size * 6;\r\n    var indices = this.indices;\r\n    if (totalIndices <= indices.length) {\r\n        return;\r\n    }\r\n    var len = indices.length || totalIndices;\r\n    while (len < totalIndices) {\r\n        len <<= 1;\r\n    }\r\n\r\n    indices = new Uint16Array(len);\r\n    this.indices = indices;\r\n\r\n    // fill the indices with the quads to draw\r\n    for (var i = 0, j = 0; i + 5 < indices.length; i += 6, j += 4) {\r\n        indices[i + 0] = j + 0;\r\n        indices[i + 1] = j + 1;\r\n        indices[i + 2] = j + 2;\r\n        indices[i + 3] = j + 0;\r\n        indices[i + 4] = j + 2;\r\n        indices[i + 5] = j + 3;\r\n    }\r\n\r\n    if (this.indexBuffer) {\r\n        this.indexBuffer.upload(indices);\r\n    } else {\r\n        var gl = this.renderer.gl;\r\n        this.indexBuffer = glCore.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);\r\n    }\r\n};\r\n\r\nTileRenderer.prototype.getShader = function (useSquare) {\r\n    return useSquare ? this.squareShader : this.rectShader;\r\n};\r\n\r\nTileRenderer.prototype.destroy = function () {\r\n    PIXI.ObjectRenderer.prototype.destroy.call(this);\r\n    this.rectShader.destroy();\r\n    this.squareShader.destroy();\r\n    this.rectShader = null;\r\n    this.squareShader = null;\r\n};\r\n\r\nPIXI.WebGLRenderer.registerPlugin('tile', TileRenderer);\r\n\r\nmodule.exports = TileRenderer;\r\n","function ZLayer() {\r\n    this.initialize.apply(this, arguments);\r\n}\r\n\r\nZLayer.prototype = Object.create(PIXI.Container.prototype);\r\nZLayer.prototype.initialize = function(tilemap, zIndex) {\r\n    PIXI.Container.apply(this, arguments);\r\n    this.tilemap = tilemap;\r\n    this.z = zIndex;\r\n};\r\n\r\nZLayer.prototype.clear = function() {\r\n    var layers = this.children;\r\n    for (var i=0; i<layers.length; i++)\r\n        layers[i].clear();\r\n    this._previousLayers = 0;\r\n};\r\n\r\nZLayer.prototype.cacheIfDirty = function() {\r\n    var tilemap = this.tilemap;\r\n    var layers = this.children;\r\n    var modified = this._previousLayers != layers.length;\r\n    this._previousLayers = layers.length;\r\n    var buf = this.canvasBuffer;\r\n    var tempRender = this._tempRender;\r\n    if (!buf) {\r\n        buf = this.canvasBuffer = document.createElement('canvas');\r\n        tempRender = this._tempRender = new PIXI.CanvasRenderer(100, 100, { view: buf });\r\n        tempRender.context = tempRender.rootContext;\r\n        tempRender.dontUseTransform = true;\r\n    }\r\n    if (buf.width != tilemap._layerWidth ||\r\n        buf.height != tilemap._layerHeight) {\r\n        buf.width = tilemap._layerWidth;\r\n        buf.height = tilemap._layerHeight;\r\n        modified = true;\r\n    }\r\n    var i;\r\n    if (!modified) {\r\n        for (i=0;i<layers.length;i++) {\r\n            if (layers[i].isModified(this._lastAnimationFrame != tilemap.animationFrame)) {\r\n                modified = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    this._lastAnimationFrame = tilemap.animationFrame;\r\n    if (modified) {\r\n        if (tilemap._hackRenderer) {\r\n            tilemap._hackRenderer(tempRender);\r\n        }\r\n        tempRender.context.clearRect(0, 0, buf.width, buf.height);\r\n        for (i=0;i<layers.length;i++) {\r\n            layers[i].clearModify();\r\n            layers[i].renderCanvas(tempRender);\r\n        }\r\n    }\r\n    this.layerTransform = this.worldTransform;\r\n    for (i=0;i<layers.length;i++) {\r\n        this.layerTransform = layers[i].worldTransform;\r\n        break;\r\n    }\r\n};\r\n\r\nZLayer.prototype.renderCanvas = function(renderer) {\r\n    this.cacheIfDirty();\r\n    var wt = this.layerTransform;\r\n    renderer.context.setTransform(\r\n        wt.a,\r\n        wt.b,\r\n        wt.c,\r\n        wt.d,\r\n        wt.tx * renderer.resolution,\r\n        wt.ty * renderer.resolution\r\n    );\r\n    var tilemap = this.tilemap;\r\n    renderer.context.drawImage(this.canvasBuffer, 0, 0);\r\n};\r\n\r\nmodule.exports = ZLayer;\r\n","PIXI.tilemap = {\r\n    ZLayer: require('./ZLayer'),\r\n    GraphicsLayer: require('./GraphicsLayer'),\r\n    RectTileLayer: require('./RectTileLayer'),\r\n    CompositeRectTileLayer: require('./CompositeRectTileLayer'),\r\n    CanvasTileRenderer: require('./CanvasTileRenderer'),\r\n    TileRenderer: require('./TileRenderer')\r\n};\r\n\r\nmodule.exports = PIXI.tilemap;\r\n","var shaderGenerator = {\r\n    fillSamplers: function(shader, maxTextures) {\r\n        var sampleValues = [];\r\n        for (var i = 0; i < maxTextures; i++)\r\n        {\r\n            sampleValues[i] = i;\r\n        }\r\n        shader.bind();\r\n        shader.uniforms.uSamplers = sampleValues;\r\n\r\n        var samplerSize = [];\r\n        for (i = 0; i < maxTextures; i++) {\r\n            samplerSize.push(1.0 / 2048);\r\n            samplerSize.push(1.0 / 2048);\r\n        }\r\n        shader.uniforms.uSamplerSize = samplerSize;\r\n    },\r\n    generateFragmentSrc: function(maxTextures, fragmentSrc) {\r\n        return fragmentSrc.replace(/%count%/gi, maxTextures)\r\n            .replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));\r\n    },\r\n    generateSampleSrc: function(maxTextures) {\r\n        var src = '';\r\n\r\n        src += '\\n';\r\n        src += '\\n';\r\n\r\n        src += 'if(vTextureId <= -1.0) {';\r\n        src += '\\n\\tcolor = shadowColor;';\r\n        src += '\\n}';\r\n\r\n        for (var i = 0; i < maxTextures; i++)\r\n        {\r\n            src += '\\nelse ';\r\n\r\n            if(i < maxTextures-1)\r\n            {\r\n                src += 'if(textureId == ' + i + '.0)';\r\n            }\r\n\r\n            src += '\\n{';\r\n            src += '\\n\\tcolor = texture2D(uSamplers['+i+'], textureCoord * uSamplerSize['+i+']);';\r\n            src += '\\n}';\r\n        }\r\n\r\n        src += '\\n';\r\n        src += '\\n';\r\n\r\n        return src;\r\n    }\r\n};\r\n\r\nmodule.exports = shaderGenerator;\r\n"],"sourceRoot":"./"}